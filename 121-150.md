第121题
```c++
class Solution {
public:
    int maxProfit(vector<int> &prices) {
        vector<int> left(prices.size(), 0), right(prices.size(), 0);
        for (int i = 0; i < prices.size(); ++i) {
            if (i == 0) left[i] = prices[i];
            else left[i] = min(prices[i], left[i - 1]);
        }
        for (int i = prices.size() - 1; i >= 0; --i) {
            if (i == prices.size() - 1) right[i] = prices[i];
            else right[i] = max(prices[i], right[i]);
        }
        int m = 0;
        for (int i = 0; i < prices.size(); ++i) {
            m = max(right[i]-left[i],m);
        }
        return m;
    }
};
```
第122题
```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        int dp[n][2];
        dp[0][0] = 0, dp[0][1] = -prices[0];
        for (int i = 1; i < n; ++i) {
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
        }
        return dp[n - 1][0];
    }
};

```

第123题
```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        int buy1 = -prices[0], sell1 = 0;
        int buy2 = -prices[0], sell2 = 0;
        for (int i = 1; i < n; ++i) {
            buy1 = max(buy1, -prices[i]);
            sell1 = max(sell1, buy1 + prices[i]);
            buy2 = max(buy2, sell1 - prices[i]);
            sell2 = max(sell2, buy2 + prices[i]);
        }
        return sell2;
    }
}
```

第124题
```c++
class Solution {
public:
    int maxSum = INT_MIN;
    int maxGain(TreeNode *node){
        if(node== nullptr) return 0;
        int left = max(maxGain(node->left),0);
        int right = max(maxGain(node->right),0);
        maxSum = max(maxSum,left+right+node->val);
        return node->val + max(left,right);
    }
    int maxPathSum(TreeNode *root) {
        maxGain(root);
        return maxSum;
    }
};
```
第125题
```c++
class Solution {
public:
    bool isPalindrome(string s) {
        string sgood;
        for (char ch: s) {
            if (isalnum(ch)) {
                sgood += tolower(ch);
            }
        }
        string sgood_rev(sgood.rbegin(), sgood.rend());
        return sgood == sgood_rev;
    }
};
```

第128题
```c++
class Solution {
public:
    int longestConsecutive(vector<int> &nums) {
        unordered_set<int> num_set;
        for (const int &num: nums) {
            num_set.insert(num);
        }
        int longerStreak = 0;
        for (const int &num: nums) {
            if (!num_set.count(num - 1)) {
                int currentNum = num;
                int currentStreak = 1;
                while (num_set.count(currentNum+1)) {
                    currentNum += 1;
                    currentStreak += 1;
                }
                longerStreak = max(longerStreak, currentStreak);
            }
        }
        return longerStreak;
    }
};
```
第129题
```c++
class Solution {
public:
    int dfs(TreeNode *root, int preSum) {
        if (root == nullptr) return 0;
        int s = preSum * 10 + root->val;
        if (root->right == nullptr && root->left == nullptr) {
            return s;
        } else {
            return dfs(root->left, s) + dfs(root->right, s);
        }
    }

    int sumNumbers(TreeNode *root) {
        return dfs(root, 0);
    }
};
```
第133题
```
package main
type Node struct {
	Val       int
	Neighbors []*Node
}
func cloneGraph(node *Node) *Node {
    visited := map[*Node]*Node{}
    var cg func(node *Node) *Node
    cg = func(node *Node) *Node {
        if node == nil {
            return node
        }
        if _,ok := visited[node]; ok{
            return visited[node]
        }
        cloneNode := &Node{Val: node.Val,Neighbors: []*Node{}}
        visited[node] = cloneNode
        for _,n :=range node.Neighbors{
            cloneNode.Neighbors = append(cloneNode.Neighbors,cg(n))
        }
        return cloneNode
    }
    return cg(node)
}

```
第134题
```go
package main
func canCompleteCircuit(gas []int, cost []int) int {
	for i, n := 0, len(gas); i < n; {
		s, cnt := 0, 0
		for cnt < n {
			j := (i + cnt) % n
			s = s + gas[j] - cost[j]
			if s < 0 {
				break
			}
			cnt++
		}
		if cnt == n {
			return i
		} else {
			i += cnt + 1
		}
	}
	return -1
}
```
第141题
```c++
class Solution {
public:
    bool hasCycle(ListNode *head) {
        while(head){
            if(head->val==100001){
                return true;
            }else{
                head->val=100001;
            }
            head = head->next;
        }
        return false;
    }
};
```

第142题
```c++
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        set<ListNode*> visited;
        ListNode* temp = head;
        while(temp){
            if(visited.count(temp)){
                return temp;
            }
            visited.insert(temp);
            temp = temp->next;
        }
        return nullptr;
    }
};
```

第143题
```c++
class Solution {
public:
    void reorderList(ListNode *head) {
        vector<ListNode*> stack;
        ListNode *temp = head;
        while(temp){
            stack.push_back(temp);
            temp = temp->next;
        }
        for (int i = 0; i < stack.size()/2; ++i) {
            stack[i]->next=stack[stack.size()-1-i];
            stack[stack.size()-1-i]->next = stack[i+1];
        }
        if (stack.size()%2==0){
            stack[stack.size()/2]->next= nullptr;
        }else{
            stack[stack.size()/2]->next= nullptr;
        }
    }
};
```

第144题
```c++
class Solution {
public:
    void dfs(TreeNode* root,vector<int>&result){
        if(root==nullptr) return;
        result.push_back(root->val);
        dfs(root->left,result);
        dfs(root->right,result);
    } 
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result;
        dfs(root,result);
        return result;
    }
};
```

第145题
```c++
class Solution {
public:
    void dfs(TreeNode* root,vector<int>&result){
        if(root==nullptr) return;

        dfs(root->left,result);
        dfs(root->right,result);
         result.push_back(root->val);
    } 
    vector<int> postorderTraversal(TreeNode* root) {
      vector<int> result;
        dfs(root,result);
        return result;
    }
};
```