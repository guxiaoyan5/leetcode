第一题：

```c++
bool comp(const vector<int> &a,const vector<int> &b){
    return a[1]<b[1];
}
class Solution {
public:
    vector<int> twoSum(vector<int> &nums, int target) {
        vector<vector<int>> data(nums.size());
        for (int i = 0; i < nums.size(); ++i) {
            data[i].push_back(i);
            data[i].push_back(nums[i]);
        }
        sort(data.begin(), data.end(), comp);
        int low = 0, high = nums.size() - 1;
        vector<int> result(2);
        while (low < high) {
            if (data[low][1] + data[high][1] < target) {
                low++;
            }
            else if (data[low][1] + data[high][1] > target) {
                high--;
            }
            else {
                result[0] = data[low][0];
                result[1] = data[high][0];
                return result;
            }
        }
    }

};
```

第二题

```c++
class Solution {
public:
    ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) {
        ListNode *temp1 = l1, *temp2 = l2;
        ListNode *result= new ListNode();
        ListNode *temp = result;
        int jinwei = 0;
        while(temp1 && temp2){
            int x = temp1->val+temp2->val+jinwei;
            ListNode *temp3 = new ListNode(x%10);
            jinwei = x / 10;
            temp->next = temp3;
            temp = temp3;
            temp1 = temp1->next;
            temp2 = temp2->next;
        }
        while(temp1){
            int x = temp1->val+jinwei;
            ListNode *temp3 = new ListNode(x%10);
            jinwei = x / 10;
            temp->next = temp3;
            temp = temp3;
            temp1 = temp1->next;
        }
        while(temp2){
            int x = temp2->val+jinwei;
            ListNode *temp3 = new ListNode(x%10);
            jinwei = x / 10;
            temp->next = temp3;
            temp = temp3;
            temp2 = temp2->next;
        }
        if(jinwei !=0){
            ListNode *temp3 = new ListNode(jinwei);
            jinwei=0;
            temp->next=temp3;
        }
        return result->next;
    }
};
```

第三题

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int visited[128];
        for (int i = 0; i < 128; ++i) {
            visited[i] = -1;
        }
        int maxs = 0;
        int k=0;
        for (int i = 0; i < s.length(); ++i) {
            if (visited[int(s[i])] != -1 && k >= i-visited[int(s[i])]){
                    k= i-visited[int(s[i])];
            }else{
                k++;
            }
            maxs = max(k,maxs);
            visited[int(s[i])] = i;
        }
        return maxs;
    }
};
```

第四题

```c++
class Solution {
public:
    double findMedianSortedArrays(vector<int> &nums1, vector<int> &nums2) {
        int m1 = nums1.size();
        int m2 = nums2.size();
        int left = (m1 + m2 + 1) / 2;
        int right = (m1 + m2 + 2) / 2;
        return (findKth(nums1, nums2, 0, 0, left) + findKth(nums1, nums2, 0, 0, right)) / 2.0;
    }

    int findKth(vector<int> &nums1, vector<int> &nums2, int i, int j, int k) {
        if (i >= nums1.size()) return nums2[j + k - 1];
        if (j >= nums2.size()) return nums1[i + k - 1];
        if (k == 1) {
            return min(nums1[i], nums2[j]);
        }
        int midVal1 = (i + k / 2 - 1 < nums1.size()) ? nums1[i + k / 2 - 1] : 1000000;
        int midVal2 = (j + k / 2 - 1 < nums2.size()) ? nums2[j + k / 2 - 1] : 1000000;
        if (midVal1 < midVal2) {
            return findKth(nums1, nums2, i + k / 2, j, k - k / 2);
        } else {
            return findKth(nums1, nums2, i, j + k / 2, k - k / 2);
        }
    }
};
```

第五题
```c++
class Solution {
public:
    string longestPalindrome(string s) {
        vector<vector<int>> dp(s.size(), vector<int>(s.size(), 0));
        int maxlenth = 0;
        int left = 0;
        int right = 0;
        for (int i = s.size() - 1; i >= 0; i--) {
            for (int j = i; j < s.size(); j++) {
                if (s[i] == s[j]) {
                    if (j - i <= 1) {
                        dp[i][j] = true;
                    } else if (dp[i + 1][j - 1]) {
                        dp[i][j] = true;
                    }
                }
                if (dp[i][j] && j - i + 1 > maxlenth) {
                    maxlenth = j - i + 1;
                    left = i;
                    right = j;
                }
            }

        }
        return s.substr(left, right - left + 1);
    }
};

```

第六题

```c++
class Solution {
public:
    string convert(string s, int numRows) {
        string r;
        if(s.size()<=numRows || numRows ==1 ){
            return s;
        }
        for (int i = 0; i < numRows; ++i) {
            int j = i;
            if (j == 0 || j == numRows - 1) {
                while (j < s.size()) {
                    r.push_back(s[j]);
                    j += 2 * (numRows - 1);
                }
            } else {
                int k = 2 * numRows - 2 - j - j;
                while (j < s.size()) {
                    r.push_back(s[j]);
                    if (j + k < s.size())
                        r.push_back(s[j + k]);
                    j += 2 * (numRows - 1);
                }
            }
        }
        return r;
    }
};
```

第七题
```c++
class Solution {
public:
    int reverse(int x) {
        long long flag = x >= 0 ? 1 : -1;
        long long x1 = flag * x;
        long long s = 0;
        int yu;
        while (x1 != 0) {
            yu = x1 % 10;
            s = s * 10 + yu;
            x1 = x1 / 10;
        }
        if (flag == -1) {
            return flag * s >= -2147483648 ? int(flag * s) : 0;
        } else {
            return s <= 2147483647 ? int(s) : 0;
        }
    }
};

```

第八题
```c++
class Solution {
public:
    int myAtoi(string s) {
        const int n = s.size();
        int i = 0;
        while(i < n && s[i] == ' ') i++;
        if(i == n) return 0;
        bool is_negtive = false;
        if(s[i] == '-' || s[i] == '+') {
            is_negtive = s[i] == '-';
            i++;
        }
        long ans = 0;
        while(i < n && isdigit(s[i])){
            ans = ans * 10 + (s[i] - '0');
            if(!is_negtive && ans > INT_MAX) return INT_MAX;
            if(is_negtive && -ans < INT_MIN) return INT_MIN;
            i++;
        }
        return is_negtive ? -ans : ans;
    }
};
```

第九题
```c++
class Solution {
public:
    bool isPalindrome(int x) {
        if (x < 0) {
            return false;
        }
        long long s = 0;
        int x1 = x;
        while (x1 != 0) {
            s = s * 10 + x1 % 10;
            x1 /= 10;
        }
        return s == x;
    }
};
```

第十题
```c++
class Solution {
public:
    bool isMatch(string s, string p) {
        int m = s.size();
        int n = p.size();

        auto matches = [&](int i, int j) {
            if (i == 0) {
                return false;
            }
            if (p[j - 1] == '.') {
                return true;
            }
            return s[i - 1] == p[j - 1];
        };

        vector<vector<int>> f(m + 1, vector<int>(n + 1));
        f[0][0] = true;
        for (int i = 0; i <= m; ++i) {
            for (int j = 1; j <= n; ++j) {
                if (p[j - 1] == '*') {
                    f[i][j] |= f[i][j - 2];
                    if (matches(i, j - 1)) {
                        f[i][j] |= f[i - 1][j];
                    }
                }
                else {
                    if (matches(i, j)) {
                        f[i][j] |= f[i - 1][j - 1];
                    }
                }
            }
        }
        return f[m][n];
    }
};

```

第十一题
```c++
class Solution {
public:
    int maxArea(vector<int> &height) {
        int left = 0,right = height.size()-1;
        int s=0,temp=0;
        while(left<right){
            if(height[left]<height[right]){
                temp = height[left] * (right-left);
                left++;
            }else{
                temp = height[right] * (right-left);
                right--;
            }
            s = max(s,temp);
        }

        return s;
    }
};

```

第十二题
```c++

class Solution {
public:
    string intToRoman(int num) {
        string s = "",s1="";
        int yushu;
        char a[4] = {'I', 'X', 'C', 'M'};
        char b[3] = {'V', 'L', 'D'};
        int k = 0;
        while (num != 0) {
            yushu = num % 10;
            switch (yushu) {
                case 3:
                    s.push_back(a[k]);
                case 2:
                    s.push_back(a[k]);
                case 1:
                    s.push_back(a[k]);
                    break;
                case 4:
                    s.push_back(b[k]);
                    s.push_back(a[k]);
                    break;
                case 9:
                    s.push_back(a[k + 1]);
                    s.push_back(a[k]);
                    break;
                case 8:
                    s.push_back(a[k]);
                case 7:
                    s.push_back(a[k]);
                case 6:
                    s.push_back(a[k]);
                case 5:
                    s.push_back(b[k]);break;
            }
            num /= 10;
            k++;
        }
        reverse(s.begin(),s.end());
        return s;
    }
};
```

第十三题
```c++
class Solution {
public:
    int romanToInt(string s) {
        int i = 0;
        int n = s.size();
        int result = 0;
        int k;
        while (i < n) {
            switch (s[i]) {
                case 'M':
                    result += 1000;
                    i++;
                    break;
                case 'D':
                    k = 1;
                    while (i+k < n && s[i + k] == 'C') k++;
                    result = result + 400 + k * 100;
                    i += k;
                    break;
                case 'C':
                    if(i+1 <n && s[i+1] == 'D'){
                        result += 400;
                        i+=2;
                    }else if(i+1 <n && s[i+1] == 'M'){
                        result += 900;
                        i+=2;
                    }else{
                        result+=100;
                        i++;
                    }
                    break;
                case 'L':
                    k = 1;
                    while (i+k < n && s[i + k] == 'X') k++;
                    result = result + 40 + k * 10;
                    i += k;
                    break;
                case 'X':
                    if(i+1 <n && s[i+1] == 'L'){
                        result += 40;
                        i+=2;
                    }else if(i+1 <n && s[i+1] == 'C'){
                        result += 90;
                        i+=2;
                    }else{
                        result+=10;
                        i++;
                    }
                    break;
                case 'V':
                    k = 1;
                    while (i+k < n && s[i + k] == 'I') k++;
                    result = result + 4 + k * 1;
                    i += k;
                    break;
                case 'I':
                    if(i+1 <n && s[i+1] == 'V'){
                        result += 4;
                        i+=2;
                    }else if(i+1 <n && s[i+1] == 'X'){
                        result += 9;
                        i+=2;
                    }else{
                        result+=1;
                        i++;
                    }
                    break;
            }
        }
        return result;
    }
};
```

第十四题
```c++
class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) {
        int n = strs.size();
        string s="";
        string temp1 = strs[0];
        string temp ;
        for (int i = 1; i < n; ++i) {
            temp = "";
            for (int j = 0; j < strs[i].size()&&j<temp1.size(); ++j) {
                if(temp1[j] == strs[i][j]){
                    temp.push_back(temp1[j]);
                }else{
                    temp1 = temp;
                    break;
                }
            }
            temp1 = temp;
        }
        return temp1;
    }
};
```